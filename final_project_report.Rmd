---
title: "Final Project Report"
author: "Pavan Narahari"
date: "2025-04-21"
output:
    rmdformats::robobook:
---

```{r setup, include=FALSE}
library(data.table)
library(tidyverse)
library(DESeq2)
library(magrittr)
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Fertility is a major issue with 1 in 6 adults experiencing fertility issues. In vitro fertilization (IVF) is a potential care path for couples experiencing fertility issues, but IVF success rates remain low. Most research around poor IVF outcomes have revolved around the influence of maternal stressors and periconceptual health. In the USA, alcohol use is widespread, however most studies exploring the interaction between alcohol and IVF focus on the female drinking or are significantly confounded by multiple lifestyle factors. This report aims to investigate the relationship between paternal drinking and its impact on IVF embryos. The following [dataset](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE214726) was used and data was collected by exposing paternal mice to alcohol free solution or 10% ethanol solution for 10 weeks. Sperm was collected and then used to fertilize eggs retrieved from alcohol free females. Oocytes underwent IVF and were incubated till the morula stage, at which point totalRNA was harvested and compared across control and experimental samples. The hypothesis under test is: Embryonic gene expression differs between embryos from paternal fathers that consume alcohol and those that don't. Specifically, there is a change in expression of Fgf4 and Egfr RNA expression.

## Dataset

The data is linked to the following publication - [Preconception paternal alcohol exposure decreases IVF embryo survival and pregnancy success rates in a mouse model](https://pmc.ncbi.nlm.nih.gov/articles/PMC9907225/).

- The data was generated by the Golding Lab at Texas A&M University in the department of Veterinary Physiology & Pharmacology.

- The RNA was extracted using the Quick Biololgy Inc. RNA isolation protocol. 
[Source](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM6615000)

- The library was prepped using the Quick Biololgy Inc. library construction protocol.
[Source](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM6615000)

- The experimental treatment/condition was defined by the Nakagata IVF protocol with CARD media. This is a method for extracting embryos from mice as defined in this [paper](https://pubmed.ncbi.nlm.nih.gov/30353518/)
[Source](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM6615000)

- The Illumina NovaSeq 6000 platform was used for sequencing.

- There are 3 samples per condition (Experimental, WT)

- The data is paired-end

- The library is unstranded

# Results

Github for report: https://github.com/naraharip2017/ANGSD-pan4008/tree/main

Through Differential Gene Expression Analysis, the hypothesis was supported that there were differences in transcript composition between embryos from paternal father that were exposed to alcohol and those that were not. Additionally, there was a downregulatin in the expression Fgf4 (Fibroblast growth factor 4) and Egfr (Epidermal growth factor), which are both critical regulators of trophectoderm stem cell growth and placental patterning. Along with similar findings to the paper that utilized this dataset, I also found differential gene expression of Gm14137 and Gbp10, both of which are believed to impact GTP binding activity. Further experiments could be conducted to perform direct KO of the genes differentially expressed in this report and directly monitor phenotypic changes to further understant their impact on a growing embryo. 

There are several limitations from the findings in this report. For example, the library was prepped using totalRNA, which captures abundant mRNA along with other non-protein coding RNAs. Additionally, as seen in the RSeQC results, there may be some degradation of transcripts causing a 3' bias. Some transcripts may be missing due to degradation impacting what is seen in the results. Finally, since the experiments were conducted on mice, it is difficult to know exactly the relationship to humans and how embryo's from different species would be impacted

# Methods

## Generating Alignment and Read Counts

### Downloading data

I first downloaded the data to my workspace using this [script](todo)

This created the directory structure with the SRR ID and sample type (experimental, WT) for tracking of the type of sample. Since the reads are paired-end there are two files per condition.

```
SRR21798749_EXP1  SRR21798750_EXP2  SRR21798751_EXP3  SRR21798755_WT1  SRR21798756_WT2  SRR21798757_WT3
```

```{bash readsPerCondition, eval=FALSE}
cd SRR21798749_EXP1
ls
```

```
SRR21798749_1.fastq.gz  SRR21798749_2.fastq.gz
```

### Pre-processing Data

Before performing alignments, I performed some quality control on the read files themselves. I first performed `fastqc` on the raw reads. I used two threads to process the two reads from paired-end reads. I used this [script](todo) to generate the fastqc reports

Investigating the reports, there were 0 sequences flagged for bad quality but there was adapter contamination.

```{r, fig.cap="Figure 1: Example FastQC report on pre-processed data showing adapter contamination - sample SRR21798749", out.width="70%"}
knitr::include_graphics("figure_imgs/pre_processed_adapter_reads.png")
```

I then ran the following [script](todo) which did the following steps:

1. `trim_galore` to remove the adapters from the reads. I passed Illumina because I knew that the sequencing was done on an Illumina platform. I outputted to a `trimmed/` directory per sample. 
2. `fastqc` was run on the trimmed samples and reports were investigated after to ensure samples removed adapters properly

After performing `fastqc` on the trimmed reads, the reports indicated adapters were removed and 0 poor quality reads still. However, the reports indicated `FAIL` for `Per base sequence content` so that may indicate a source of bias or error in subsequent analysis. Though looking at the plots for the samples, with an example below there looks to be a drop in A%, which may be due to the poly-A tail being trimmed. 


```{r, fig.cap="Figure 2: Example Post Trimmed FastQC report on pre-processed data showing adapter contamination - sample SRR21798749", out.width="70%"}
knitr::include_graphics("figure_imgs/post_trimmed_fastqc.png")
```

```{r, fig.cap="Figure 3: Example Post Trimmed FastQC report Per Base Sequence Content - sample SRR21798749", out.width="70%"}
knitr::include_graphics("figure_imgs/per_base_sequence_content.png")
```

### Creating Reference Genome

I downloaded a reference genome from ucsc as the publication linked to the dataset retrieved their data from the `UCSC m39` reference genome. I downloaded the `.fa` file and `.gtf` files from the following locations 

```{bash Q2DownloadRefGenome, eval=FALSE}
wget ftp://hgdownload.soe.ucsc.edu/goldenPath/mm39/bigZips/mm39.fa.gz
```

```{bash Q2DownloadRefGenomeGtf, eval=FALSE}
wget ftp://hgdownload.soe.ucsc.edu/goldenPath/mm39/bigZips/genes/refGene.gtf.gz
```

I then created a reference genome to perform an alignment for the RNA data

```{bash Q2DGenerateSTARRefGenome, eval=FALSE}
STAR --runMode genomeGenerate --runThreadN 10 --genomeDir Mus_musculusSTARindex/ --genomeFastaFiles mm39.fa --sjdbGTFfile refGene.gtf --sjdbOverhang 149
```

I used a sjdbOverhang of 149 because the length of the reads in my dataset are 150, and the help menu says to use `readLength-1` for the parameter

### Aligning Samples

I then ran the following [script](todo) to perform the alignment between the trimmed samples and the reference genome. I passed the parameter `--alignIntronMax 100000` so that reads that map to large intron junction as a technical artifact are removed from the mappings.

Table 1: Example Alignment statistics for sample `SRR21798749_EXP1`
```
                                    Finished on |       Feb 24 02:14:45
       Mapping speed, Million of reads per hour |       36.40

                          Number of input reads |       8342560
                      Average input read length |       282
                                    UNIQUE READS:
                   Uniquely mapped reads number |       4903498
                        Uniquely mapped reads % |       58.78%
                          Average mapped length |       264.47
                       Number of splices: Total |       3564048
            Number of splices: Annotated (sjdb) |       3420327
                       Number of splices: GT/AG |       3458763
                       Number of splices: GC/AG |       26843
                       Number of splices: AT/AC |       3729
               Number of splices: Non-canonical |       74713
                      Mismatch rate per base, % |       0.55%
                         Deletion rate per base |       0.01%
                        Deletion average length |       1.93
                        Insertion rate per base |       0.01%
                       Insertion average length |       1.31
                             MULTI-MAPPING READS:
        Number of reads mapped to multiple loci |       513674
             % of reads mapped to multiple loci |       6.16%
        Number of reads mapped to too many loci |       62074
             % of reads mapped to too many loci |       0.74%
                                  UNMAPPED READS:
  Number of reads unmapped: too many mismatches |       0
       % of reads unmapped: too many mismatches |       0.00%
            Number of reads unmapped: too short |       2764743
                 % of reads unmapped: too short |       33.14%
                Number of reads unmapped: other |       98571
                     % of reads unmapped: other |       1.18%
                                  CHIMERIC READS:
                       Number of chimeric reads |       0
                            % of chimeric reads |       0.00%
```

### Feature counts

I then ran the following [script](todo) to run `featureCounts` to attribute genes to the alignments performed. I passed the parameters `-Q 10` to consider a minimum mapping quality per read of 10 to stay in line with the process from the original paper. I used the `refGene.gtf` from UCSC and passed `-p` and `--countReadPairs` to properly handle the paired-end reads. `-T 8` was passed to use additional threads.

The `featureCounts` produced a `musmusculus_fc.txt` output, which I then used for subsequent differential gene expression investigations. 

### Alignment QC

Prior to performing differential gene expression analysis, I performed QC on the  generated alignments for each sample. I ran `rseqc`, which required a BED file for the reference genome rather than a `.gtf` file. I utilized `UCSC` tools to generate a BED file from the earlier downloaded `refGene.gtf.gz` file. 

```{bash createBEDFile, eval=FALSE}
conda create --name pan4008 python=3.10
conda install -c bioconda ucsc-gtftogenepred ucsc-genepredtobed
gtfToGenePred refGene.gtf refGene.genePred
genePredToBed refGene.genePred refGene.bed
```

After creating the BED file, I then performed `rseqc` analysis on the aligned reads and the BED file, and then ran multiqc for the read distribution and gene body coverage plots

```{bash generateRseqcPlots, eval=FALSE}
cd rseqc
conda activate multiqc
multiqc .
```

```{r, fig.cap="Figure 4: RSEQC Read Distribution Plot", out.width="70%"}
knitr::include_graphics("figure_imgs/rseqc_read_distribution_plot.png")
```

The read distribution plot shows some intergenic reads, showing a potential source of low quality reads.


```{r, fig.cap="Figure 5: RSEQC Gene Body Coverage Plot", out.width="70%"}
knitr::include_graphics("figure_imgs/rseqc_gene_body_coverage_plot.png")
```

The gene body coverage plot shows some bias towards the 3' end showing there may be some mRNA degradation occurring, which was captured in the library.

I then plotted the aligned reads per sample to make sure most were aligned. There looks to be some reads that were multimapped, ambiguous, or no features, which is something that may have impacted subsequent analysis.

```{r}
process_data_for_ggplot <- function(file, filter_categories) {
  summary_data <- read.table(file, header=TRUE, row.names = 1, sep = "\t")
  transposed_data <- as.data.frame(t(summary_data))
  transposed_data$Sample <- rownames(transposed_data)
  rownames(transposed_data) <- NULL
  transposed_data <- transposed_data %>% relocate(Sample)
  
  long_data <- transposed_data %>%
  pivot_longer(cols = -Sample, 
               names_to = "Status", 
               values_to = "Counts")
  
    sample_mapping <- c(
    "SRR21798749.SRR21798749.Aligned.sortedByCoord.out.bam" = "EXP_1",
    "SRR21798750.SRR21798750.Aligned.sortedByCoord.out.bam" = "EXP_2",
    "SRR21798751.SRR21798751.Aligned.sortedByCoord.out.bam" = "EXP_3",
    "SRR21798755.SRR21798755.Aligned.sortedByCoord.out.bam" = "WT_1",
    "SRR21798756.SRR21798756.Aligned.sortedByCoord.out.bam" = "WT_2",
    "SRR21798757.SRR21798757.Aligned.sortedByCoord.out.bam" = "WT_3"
  )

  long_data$Sample <- recode(long_data$Sample, !!!sample_mapping)

  long_data <- long_data %>%
    filter(Status %in% filter_categories)

  return(long_data)
}
```

```{r}
gene_count_data = process_data_for_ggplot("musmusculus_fc.txt.summary", c("Assigned", "Unassigned_Ambiguity", "Unassigned_NoFeatures", "Unassigned_MultiMapping"))

head(gene_count_data)

plot <- ggplot(gene_count_data, aes(x = Counts, y = Sample, fill = Status)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "# Reads", y = "Sample", title = "Figure 6: Reads for Each Status Per Sample")

plot
```


## Reading Data into R and Post Alignment Processing

```{r load_counts_data}
df_counts <- read.table("musmusculus_fc.txt", header = TRUE)
str(df_counts)
orig_names <- names(df_counts)
new_names <- c(names(df_counts)[1:6], paste("EXP", c(1:3), sep = "_"), paste("WT", c(1:3), sep = "_"))
names(df_counts) <- new_names
str(df_counts)
row.names(df_counts) <- make.names(df_counts$Geneid)
cts_gene_sample <- df_counts[ , -c(1:6)]
head(cts_gene_sample)
```

```{r load_coldata}
df_coldata <- data.frame(condition = gsub("_[0-9]+", "", names(cts_gene_sample)),
row.names = colnames(cts_gene_sample))

df_coldata

str(df_coldata)
```

```{r create_dds_object}
dds_gierlinski <- DESeqDataSetFromMatrix(countData = cts_gene_sample,
colData = df_coldata,
design = ~ condition)
dds_gierlinski
```

```{r add_row_data}
df_rowdata <- df_counts[, 1:6]
rowData(dds_gierlinski) <- df_rowdata
dds_gierlinski
```


```{r view_data}
head(counts(dds_gierlinski))
colSums(counts(dds_gierlinski)) %>% barplot
dim(dds_gierlinski)
keep_genes <- rowSums(counts(dds_gierlinski)) > 0
dds_gierlinski <- dds_gierlinski[ keep_genes, ]
dim(dds_gierlinski)
counts(dds_gierlinski) %>% str
dds_gierlinski <- estimateSizeFactors(dds_gierlinski)
plot( sizeFactors(dds_gierlinski), colSums(counts(dds_gierlinski)), # assess them
ylab = "library sizes", xlab = "size factors", cex = .6 )
par(mfrow=c(1,2))
counts.sf_normalized <- counts(dds_gierlinski, normalized=TRUE)
boxplot(counts(dds_gierlinski), main = "read counts only", cex = .6)
boxplot(counts.sf_normalized, main = "SF normalized", cex = .6)
assay(dds_gierlinski, "log_counts") <- log2(counts(dds_gierlinski, normalized = FALSE) + 1)
assay(dds_gierlinski, "log_norm_counts") <- log2(counts(dds_gierlinski, normalized=TRUE) + 1)
dds_gierlinski
```

```{r}
par(mfrow=c(1,2))
dds_gierlinski[, c("WT_1","WT_2")] %>%
assay(., "log_norm_counts") %>%
plot(., cex=.1, main = "WT_1 vs. WT_2")
dds_gierlinski[, c("EXP_1","EXP_2")] %>%
assay(., "log_norm_counts") %>%
plot(., cex=.1, main = "EXP_1 vs EXP_2")
```

### Run differential gene expression analysis with DESeq2

Note that we first need to relevel the values in our design matrix, so that the control condition we are comparing to is the WT.

```{r perform_dge, message=FALSE}
dds_gierlinski$condition %<>% relevel(ref="WT")

dds_gierlinski <- DESeq(dds_gierlinski)
DGE_results <- results(dds_gierlinski,
                       independentFiltering = TRUE,
                       alpha = 0.05,
                       saveCols="Length")
gene_list <- DGE_results$log2FoldChange
names(gene_list) <- rownames(DGE_results)
gene_list <- sort(gene_list, decreasing = TRUE)
head(gene_list)
```

Next we subset our results to just those genes whose adjusted p-values (after multiple hypothesis correction) pass our statistical threshold of 0.05. These are the genes that we are labeling as differentially expressed.

```{r get_deg}
DGE_genes <- subset(DGE_results, padj < 0.05)
DGE_genes <- DGE_genes[order(DGE_genes$padj), ]
top5_genes <- head(DGE_genes, 5)
top5_genes
knitr::kable(top5_genes, caption = "Top 5 Differentially Expressed Genes (sorted by adjusted p-value)")
```

### Go Term Enrichment Analysis

For GO term enrichment analysis, we need the vector of differentially expressed genes (`DGE_genes`).

# Discussion

- intron junctions
- feature count params
- rseqc
- 6% alcohol

Run scripts in following order to reproduce results in report:

1. download_samples.sh
2. run_preprocessing_fastqc.sh
3. trim_samples_run_fastqc.sh
4. align_reads.sh
5. run_feature_counts.sh
6. run_rseqc.sh

I ran into the following issues during my analysis.

1. During alignment viewing in IGV, I found there were many poor reads with large intron junctions, which would completely bypass whole genes. This is a result of technical mapping artifacts and not actually transcripts due to exon splicing. I re-ran my alignments to avoid these technical intron junctions 


# References